### API

---
# Деплой нового функционала/фичи на прод
### Локальные изменения:
1. `git checkout develop` - открыть локальную ветку `develop`.
2. `git pull` - подтянуть в нее последние изменения репозитория с гитхаба.
3. `git checkout -b feature/branch-name` - cоздать локально дочернюю ветку от develop для разрабатываемой фичи (при этом необходимо находиться непосредственно в ветке `develop`), желательно с именованием `feature/branch-name`, `fix/branch-name` (если нужно исправить ошибки или логику функционала) или `chore/branch-name` (если нужно решить задачу, не повлияющую на производственный код), перейдя сразу в эту ветку.
4. Реализовать функционал / задачу.
5. После окончания работы, вы выполняете такие шаги:

- `git checkout develop` - Переходите в ветку develop
- `git pull` - пуллите изменения, которые могли там оказаться за время выполнения вашей задачи
- `git checkout feature/branch-name` Возвращаетесь в свою ветку с новым функционалом
- `git merge --no-ff develop` - вносите в свою ветку изменения, которые появились в девелопе (ваш код останется)
- `git add .` - добавляете в отслеживание версий все файлы, которые были изменены
- `git commit -m “Feature comment”` - коммитите изменения именем реализованного функционала

Если делаете несколько задач - для каждой создаете отдельную ветку `fix/branch-name`, `feature/branch-name` и т.д.
Под конец просто пушите ветку в репу, находиться нужно в своей ветке!!! И лучше еще раз cделать `git pull` в девелопе и `merge --no-ff` девелопа в своей ветке
`git push --set-upstream origin branch-name`

### Изменения на гитхабе:
1. Создать `pull request (PR)` на слияние добавленной вами ветки с веткой `develop` и добавить в pull request одного из разработчиков вашего направления, чтобы он мог осуществить ревью кода. Если возникли конфликты - смотрите памятку по рещению конфликтов ниже.
2. Если разработчик не указал никаких комментариев и сразу одобрил предложенный вами код - закрываете `PR` и мержите изменения в `develop`.
Если разработчик предложил свои комментарии для улучшения вашего кода - вы локально выполняете следующие действия:
- `git checkout feature/branch-name` - переходите в ветку вашей фичи
- Вносите необходимые изменения в код
- `git add .` - добавляете в отслеживание версий все файлы, которые были изменены
- `git commit -m “Feature comment”` - коммитите изменения именем реализованного функционала
- `git push --set-upstream origin branch-name` - загружаете изменения на гитхаб
Изменения автоматически подгрузятся в pull request.
3. После того, как актуальные изменения загрузились в `develop` - удалить созданную вами ветку новой фичи, если никакие изменения больше не потребуются.

### Памятка для решения конфликтов, возникших при создании pull request:
Если при создании pull request гитхаб выкатил сообщение о невозможности автоматического слияние веток - он предложит вам решить конфликты либо локально, либо в веб-редакторе (если конфликты не слишком закомплексованы)
В первом случае в сообщении о концликте вы нажимаете на web-editor и редактируете конфликты в коде, представленном в веб-редакторе гитхаба (в этом коде внутри возникших конфликтов вам необходимо оставить актуальные изменения кода и удалить изменения, которые больше не нужны). После внесенных изменений - не забыть подтвердить решение конфликтов, нажав зеленую кнопку resolve conflicts справа в верхнем углу файла и подтвердить мерж изменений.
Во втором случае вам необходимо выполнить следующие действия:
- `git checkout develop` - переходите в ветку develop (либо в другую ветку, в которую вам нужно вмержить вашу)
- `git merge feature/branch-name` - мержите в текущую ветку изменения из той, которую вам необходимо подгрузить
- Решаете возникшие конфликты. При этом необходимо отслеживать текущую версию изменений (HEAD) и входящие изменения (Incoming changes) для того, чтобы определить, какие из них нужно оставить, а какие - удалить.
- После решения всех конфликтов - вы фиксируете внесенные изменения `git add .`, коммитите их `git commit -m “Feature comment”` и пушите на гитхаб ветку develop (ту ветку, в которую вы мержили изменения локально): `git push --set-upstream origin develop`
В результате пуша на удаленном репозитории гитхаба в ветке develop подгрузятся внесенные вами локально изменения кода.

### Примечания для sheriff - разработчика:
1. Создаеть ветку `release-*` от ветки `develop` в конце недели или какие сроки будут заявлены.
2. Заливаете все на прод (`git flow` сделает это за вас, просто проследите за `actions`).
3. Радуетесь что все работает на проде. (опционально)
2. Пушите все имеющееся в ветке `release-*` в ветку `master`.

### pre-commit установка

`pre-commit` поможет избавиться от pep8 ошибок и импортов перед коммитом в репу

**Установка:**
```bash
pre-commit install
```

**Использование:**
```bash
pre-commit run --all-files
```

Также используется автоматически при коммите! (если что-то не так - информирует
 и не дает коммиту пройти до фикса проблемы)


## Фронтенд

### Окружение

- [Node.js 20 (LTS) и новее](https://nodejs.org/en/download)

### Настройка переменных окружения

Чтобы работал поиск по изображениям, необходимо получить ключ доступа к API Unsplash.
Для этого [зарегистрируйтесь на Unsplash, создайте приложение](https://unsplash.com/documentation#creating-a-developer-account) и скопируйте Access Key.

После получения Access Key, в проекте в директории `/frontend` нужно создать копию файла `.env.example` и переименовать его в `.env`.
В файле `.env` заменить у переменной `VITE_APP_UNSPLASH_ACCESS_KEY` значение на ранее полученный Access Key.

### Установка зависимостей

Перейти в директорию `frontend` и установить зависимости:

```sh
cd frontend
npm install
```

### Запуск фронтенд-сервера

Запустить фронтенд-сервер:

```sh
npm start
```

Фронтенд-сервер запустится по адресу: http://localhost:5273

### Сборка фронтенда

Собрать фронтенд для деплоя:

```shell
npm run build
```

Готовый фронтенд будет в папке `dist`.

### Стиль кода

#### Общие принципы:

- Переменные и функции: Именуйте переменные и функции так, чтобы они отражали своё назначение, используйте camelCase.  Названия функций должны быть глаголами или содержать глагол, указывающий на выполняемое действие (например, fetchData, calculateNumber).
- Константы: Используйте UPPER_CASE для констант.
- Компоненты: Для именования используйте PascalCase.
- Современный JS: Используйте синтаксис ES6+ для объявления переменных (const, let) и стрелочные функции.
- Обеспечьте код комментариями в сложных или непонятных местах.


Примеры:
const userName = 'Ivan'; // Хорошо: camelCase и понятное имя
const MAX_USERS = 25;    // Хорошо: константы в UPPER_CASE
function calculateTotal(sum, tax) {
  return sum + tax;
} // Хорошо: функция с глаголом в названии, описывающим действие

#### Наименование файлов и папок

- Папки именуются в нижнем регистре, слова разделяются дефисами (например, `components`, `utils`).
- Имена файлов компонентов записываются в PascalCase (например, `MyComponent.tsx`).
- Файлы стилей называются c расширением `.module.css` или `.module.scss` (например, `styles.module.scss`).
- Реэкспорт через `index.ts`: В каждой папке компонента рекомендуется использовать файл index.ts для реэкспорта компонента.
- Компонент, его стиль и `index.ts` помещаются в одну папку.
- Хуки и утилиты именуются в camelCase (например, `useFetchData.ts`, `formatDate.ts`).

Пример структуры директорий:
/src
/components
/MyComponent
- MyComponent.tsx
- styles.module.css
- index.ts
/utils
- formatDate.ts
- useFetchData.ts

// В файле /components/MyComponent/index.ts
export { default as MyComponent } from './MyComponent';

// Импорт в другом файле
import { MyComponent } from '../components/MyComponent'


### Методология БЭМ

#### Основные принципы:

- Блок: Функционально независимый компонент страницы, который может быть повторно использован.
- Элемент: Составная часть блока, которая не может использоваться отдельно от него.
- Модификатор: Свойства, которые изменяют внешний вид или поведение блока или элемента.

#### Именование:

- Используйте имя-блока__имя-элемента_имя-модификатора_значение-модификатора.
- Разделяйте имя блока и элемента двойным подчеркиванием (__).
- Разделяйте имя модификатора и его значение одинарным подчеркиванием (_).

Пример:
.button__icon_size_large {
    /* Стили для большой иконки внутри кнопки */
}

#### Практическое использование:

- Используйте БЭМ для организации стилей.


### Использование Storybook

#### Установка и запуск
Установите зависимости:

```
cd frontend
npm install
```

#### Запустите Storybook:
```
npm run storybook
```
Storybook откроется по адресу http://localhost:6006.

#### Примеры
См. storybook/example-files с документацией и примерами использования, предоставленными storybook при установке.
