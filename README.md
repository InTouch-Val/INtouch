### API

---
# Деплой нового функционала/фичи на прод
### Локальные изменения:
1. `git checkout develop` - открыть локальную ветку develop.
2. `git pull` - подтянуть в нее последние изменения репозитория с гитхаба.
3. `git checkout -b feature/branch_name` - cоздать локально дочернюю ветку от develop для разрабатываемой фичи (при этом необходимо находиться непосредственно в ветке develop), желательно с именованием feature/название_вашей_фичи, fix/branch_name (если нужно исправить ошибки или логику функционала) или chore/branch_name (если нужно решить задачу, не повлияющую на производственный код), перейдя сразу в эту ветку.
4. Реализовать функционал / задачу.
5. После окончания работы, вы выполняете такие шаги:

- `git checkout develop` - Переходите в ветку develop
- `git pull` - пуллите изменения, которые могли там оказаться за время выполнения вашей задачи
- `git checkout feature/branch_name` Возвращаетесь в свою ветку с новым функционалом
- `git rebase develop` - вносите в свою ветку изменения, которые появились в девелопе (ваш код останется)
- `git add .` - добавляете в отслеживание версий все файлы, которые были изменены
- `git commit -m “Feature comment”` - коммитите изменения именем реализованного функционала

Зачем это нужно?
Если делаете несколько задач - для каждой создаете отдельную ветку fix/name, feature/name и т.д.
Под конец просто пушите ветку в репу, находиться нужно в своей ветке!!! и лучше еще раз cделать pull девелопа и rebase девелопа в своей ветке
`git push --set-upstream origin branch_name`

### Изменения на гитхабе:
1. Создать pull request на слияние добавленной вами ветки с веткой develop и добавить в pull request одного из разработчиков вашего направления, чтобы он мог осуществить ревью кода. Если возникли конфликты - смотрите памятку по рещению конфликтов ниже.
2. Если разработчик не указал никаких комментариев и сразу одобрил предложенный вами код - закрываете pull request и мержите изменения в develop.
Если разработчик предложил свои комментарии для улучшения вашего кода - вы локально выполняете следующие действия:
- `git checkout feature/branch_name` - переходите в ветку вашей фичи
- Вносите необходимые изменения в код
- `git add .` - добавляете в отслеживание версий все файлы, которые были изменены
- `git commit -m “Feature comment”` - коммитите изменения именем реализованного функционала
- `git push --set-upstream origin branch_name` - загружаете изменения на гитхаб
Изменения автоматически подгрузятся в pull request.
3. После того, как актуальные изменения загрузились в develop - удалить созданную вами ветку новой фичи, если никакие изменения больше не потребуются.

### Памятка для решения конфликтов, возникших при создании pull request:
Если при создании pull request гитхаб выкатил сообщение о невозможности автоматического слияние веток - он предложит вам решить конфликты либо локально, либо в веб-редакторе (если конфликты не слишком закомплексованы)
В первом случае в сообщении о концликте вы нажимаете на web-editor и редактируете конфликты в коде, представленном в веб-редакторе гитхаба (в этом коде внутри возникших конфликтов вам необходимо оставить актуальные изменения кода и удалить изменения, которые больше не нужны). После внесенных изменений - не забыть подтвердить решение конфликтов, нажав зеленую кнопку resolve conflicts справа в верхнем углу файла и подтвердить мерж изменений.
Во втором случае вам необходимо выполнить следующие действия:
- `git checkout develop` - переходите в ветку develop (либо в другую ветку, в которую вам нужно вмержить вашу)
- `git merge feature/branch_name` - мержите в текущую ветку изменения из той, которую вам необходимо подгрузить
- Решаете возникшие конфликты. При этом необходимо отслеживать текущую версию изменений (HEAD) и входящие изменения (Incoming changes) для того, чтобы определить, какие из них нужно оставить, а какие - удалить.
- После решения всех конфликтов - вы фиксируете внесенные изменения `git add .`, коммитите их `git commit -m “Feature comment”` и пушите на гитхаб ветку develop (ту ветку, в которую вы мержили изменения локально): `git push --set-upstream origin develop`
В результате пуша на удаленном репозитории гитхаба в ветке develop подгрузятся внесенные вами локально изменения кода.

### Примечания для sheriff - разработчика:
1. Создать pull request из ветки develop в master и указать в качестве ревьюера вашего тимлидера для последующей проверки кода. При наличии комментариев - смотрите п 2 из вышеприведенной памятки Изменения на гитхабе.
2. Проверить отсутствие конфликтов. Если они есть - решить в веб-редакторе (посмотреть вышеприведенную памятку для решения конфликтов). Если какие то конфликты касаются не вашей разработки - обратиться к ответственному разработчику и решить их сообща.

### pre-commit установка

`pre-commit` поможет избавиться от pep8 ошибок и импортов перед коммитом в репу

**Установка:**
```bash
pre-commit install
```

**Использование:**
```bash
pre-commit run --all-files
```

Также используется автоматически при коммите! (если что-то не так - информирует
 и не дает коммиту пройти до фикса проблемы)

### Регистрация и авторизация
**GET: api/v1/users/** - список пользователей  
**POST: api/v1/users/** - регистрация пользователя  
Тело запроса: first_name, last_name, email, password, confirm_password, accept_policy.  
**GET: api/v1/confirm-email/{pk}/{token}/**  - активация аккаунта
pk, token из url из письма. Возвращает access и refresh токены.  
**POST: api/v1/token/** - авторизация  
Тело запроса: username, password. Возвращает access и refresh токены.  
**POST: api/v1/token/refresh/**  обновление токенов  
Тело запроса: refresh. Возвращает access и refresh токены.  
**GET: api/v1/get-user/** - получение данных авторизованного пользователя  
**POST: api/v1/password/reset/** - запрос на восстановление пароля  
Тело запроса: email  
**GET: api/v1/password/reset/confirm/{pk}/{token}/** - подтверждение сброса пароля  
pk, token из url из письма. Возвращает access и refresh токены.  
**POST: api/v1/password/reset/complete/** - установка нового пароля  
Тело запроса: new_password, confirm_new_password  

**POST: api/v1/clients/add/** - добавление клиента  
Тело запроса: first_name, last_name, email  
Клиент переходит по ссылке из письма на 127.0.0.1:3000/activate-client/{pk}/{token}/  
Обработка данного запроса на фронте, ответный запрос на api  
**GET: api/v1/confirm-email/{pk}/{token}/** - активация клиента  
pk, token из url из письма. Возвращает access и refresh токены.  
**PUT: api/v1/update-client/{pk}/** - завершение регистрации клиента  
Тело запроса:  
Автозаполненные: first_name, last_name, email  
Вводимые пользователем: password, confirm_password, accept_policy  
**PUT: api/v1/user/update/{pk}/** - изменение данных пользователя  
Тело запроса: first_name, last_name, email, date_of_birth, photo  
**POST: api/v1/user/update/password/** - изменение пароля пользователя  
Тело запроса: password, new_password, confirm_new_password  
**DELETE: api/v1/client/delete/{pk}/** - удаление клиента  
**PUT: api/v1/client/update/{pk}/** - редактирование данных о клиенте  
Тело запроса: date_of_birth, client{diagnosis, about}
**POST: api/v1/user/update/email/** - запрос на смену эл.почты. Тело запроса: new_email
**GET: api/v1/user/update/email/confirm/{pk}/{token}/** - подтверждение смены почты. pk, token из url письма подтверждения.

### Задачи
**POST: api/v1/assignments/** - создание задачи  
Тело запроса: title, text, assignment_type, tags, language, image_url, blocks[question, description, type, choice_replies[reply, reply ...], start_range, end_range]  

**GET: api/v1/assignments?limit=`<int>`&offset=`<int>`&ordering=`-add_date/add-date&`author=`<int>`&favourites=`<true/false>`&ordering=`-share/share`&language=`<str>`&assingment_type=`<str>`&search=`<str>`** - список задач
- `"limit"` - кол-во возвращаемых заданий
- `"offset"` - начальная точка, с какого задания начинать, по-хорошему должно быть 0
- `"author"` - `id` автора, нужен для фильтрации `My tasks`
- `"favourites"` - избранные, передавать true, чтобы вернуть избранные записи (если не тру, то не сработает, т.е не обязательно передавать false, а проще вообще не передавать)
- `"-add-date / add-date"` - если передавать с минусом, от новых -> старым, если просто то от старых -> новым  
*!!! нельзя передавать вместе с `-share/share` !!!*
- `"-share / share"` если передавать с минусом, от больших -> меньшему, если просто, то от меньших -> большему  
*!!! нельзя передавать вместе с `-add-date/add-date` !!!*
- `"language"` - выбирается из списка языков, который обговаривался ранее (по тегам `en`, `de` и т.д.)
- `"search"` - добавился параметр `search` теперь можно передавать сюда строку из строки поиска на странице `assignments`, поиск будет производится по схожим в параметре `title`
- `"assignment_type"` - выбирается из левой части списка `ASSIGNMENT_TYPES`, правая расшифровка, это нововведение для облегчения жизни и нам, и вам прикладываю его ниже вместе с тегами языков  
```python
ASSIGNMENT_TYPES = [
    ("lesson", "Lesson"),
    ("exercise", "Exercise"),
    ("essay", "Essay"),
    ("study", "Study"),
    ("quiz", "Quiz"),
    ("methodology", "Methodology"),
    ("metaphors", "Metaphors"),
]

LANGUAGES = [
    ("fr", "French"),
    ("en", "English"),
    ("es", "Spanish"),
    ("de", "German"),
    ("it", "Italian"),
    ("ot", "Other"),
]
```

**GET: api/v1/assignments/{pk}/** - получение задачи по id  
**DELETE: api/v1/assignments/{pk}** - удаление задания  
**PUT: api/v1/assignments/{pk}** - редактирование задания  
**GET: api/v1/assignments/{pk}/draft/** - перемещение задания в draft  
**GET: api/v1/assignments/add-list/{pk}/** - добавление задачи в My List  
**GET: api/v1/assignments/delete-list/{pk}/** - удаление задачи из My List  
**GET: api/v1/assignments/set-client/{pk}/{client_pk}/** - назначение задачи клиенту  
**GET: api/v1/assignments-client?user=`<user_id>`&limit=`<int>`&offset=`<int>`** - список задач клиентов  
Теперь имеет возможности передавать `query` параметры для фильтра:  
- `"user"` - клиент  
- `"limit"` - кол-во возвращаемых заданий
- `"offset"` - начальная точка, с какого задания начинать, по-хорошему должно быть 0  

_**Возможно стоит применить логику из api/v1/diary-notes/_

**GET: api/v1/assignments-client/{pk}/** - получение задачи клиента по id  
**DELETE: api/v1/assignments-client/{pk}/** - удаление задания клиента  
**PUT: api/v1/assignments-client/{pk}/** - редактирование задания клиента  
**GET: api/v1/assignments-client/{pk}/complete/** - смена статуса задания на DONE  
**GET: api/v1/assignments-client/{pk}/clear/** - очистка задания клиента  
**POST: api/v1/assignments-client/pk/visible/** - изменение видимости записи в задания для доктора  
Дубликат задания клиента - запрос на **GET: api/v1/assignments/set-client/{pk}/{client_pk}/**  
pk - из поля assignments_root  

### Заметки
**GET: api/v1/notes/** - список заметок  
**GET: api/v1/notes/{pk}/** - получение заметки по id  
**POST: api/v1/notes/** - создание заметки  
Тело запроса: title, content  
**DELETE: api/v1/notes/{pk}/** - удаление заметки  

### Дневники
**GET: api/v1/diary-notes?author=`<user_id>`&limit=`<int>`&offset=`<int>`** - список заметок в дневнике  
Теперь имеет возможности передавать `query` параметры для фильтра:  
- `"author"` - автора заметки  
клиент не нуждается в фильтре, ему возвращаются свои записи, фильтр нужен только для доктора
- `"limit"` - кол-во возвращаемых заданий
- `"offset"` - начальная точка, с какого задания начинать, по-хорошему должно быть 0  
_TODO: Возможно стоит поменять логику, но смысл возвращать клиенту больше чем свои записи? Тем более придется мучаться с пермишенами_

**GET: api/v1/diary-notes/{pk}/** - получение заметки в дневнике по id  
**POST: api/v1/diary-notes/** - создание заметки в дневнике  
Тело запроса: title, content  
**DELETE: api/v1/diary-notes/{pk}/** - удаление заметки в дневнике  
**POST: api/v1/diary-notes/pk/visible/** - изменение видимости записи в дневнике

## Фронтенд

### Окружение

- [Node.js 20 (LTS) и новее](https://nodejs.org/en/download)

### Настройка переменных окружения

Чтобы работал поиск по изображениям, необходимо получить ключ доступа к API Unsplash.
Для этого [зарегистрируйтесь на Unsplash, создайте приложение](https://unsplash.com/documentation#creating-a-developer-account) и скопируйте Access Key.

После получения Access Key, в проекте в директории `/frontend` нужно создать копию файла `.env.example` и переименовать его в `.env`.
В файле `.env` заменить у переменной `VITE_APP_UNSPLASH_ACCESS_KEY` значение на ранее полученный Access Key.

### Установка зависимостей

Перейти в директорию `frontend` и установить зависимости:

```sh
cd frontend
npm install
```

### Запуск фронтенд-сервера

Запустить фронтенд-сервер:

```sh
npm start
```

Фронтенд-сервер запустится по адресу: http://localhost:5273

### Сборка фронтенда

Собрать фронтенд для деплоя:

```shell
npm run build
```

Готовый фронтенд будет в папке `dist`.

### Стиль кода

#### Общие принципы:

- Переменные и функции: Именуйте переменные и функции так, чтобы они отражали своё назначение, используйте camelCase.  Названия функций должны быть глаголами или содержать глагол, указывающий на выполняемое действие (например, fetchData, calculateNumber).
- Константы: Используйте UPPER_CASE для констант.
- Компоненты: Для именования используйте PascalCase.
- Современный JS: Используйте синтаксис ES6+ для объявления переменных (const, let) и стрелочные функции.
- Обеспечьте код комментариями в сложных или непонятных местах.


Примеры:
const userName = 'Ivan'; // Хорошо: camelCase и понятное имя
const MAX_USERS = 25;    // Хорошо: константы в UPPER_CASE
function calculateTotal(sum, tax) {
  return sum + tax;
} // Хорошо: функция с глаголом в названии, описывающим действие

#### Наименование файлов и папок

- Папки именуются в нижнем регистре, слова разделяются дефисами (например, `components`, `utils`).
- Имена файлов компонентов записываются в PascalCase (например, `MyComponent.tsx`).
- Файлы стилей называются c расширением `.module.css` или `.module.scss` (например, `styles.module.scss`).
- Реэкспорт через `index.ts`: В каждой папке компонента рекомендуется использовать файл index.ts для реэкспорта компонента.
- Компонент, его стиль и `index.ts` помещаются в одну папку.
- Хуки и утилиты именуются в camelCase (например, `useFetchData.ts`, `formatDate.ts`).

Пример структуры директорий:
/src
/components
/MyComponent
- MyComponent.tsx
- styles.module.css
- index.ts
/utils
- formatDate.ts
- useFetchData.ts

// В файле /components/MyComponent/index.ts
export { default as MyComponent } from './MyComponent';

// Импорт в другом файле
import { MyComponent } from '../components/MyComponent'


### Методология БЭМ

#### Основные принципы:

- Блок: Функционально независимый компонент страницы, который может быть повторно использован.
- Элемент: Составная часть блока, которая не может использоваться отдельно от него.
- Модификатор: Свойства, которые изменяют внешний вид или поведение блока или элемента.

#### Именование:

- Используйте имя-блока__имя-элемента_имя-модификатора_значение-модификатора.
- Разделяйте имя блока и элемента двойным подчеркиванием (__).
- Разделяйте имя модификатора и его значение одинарным подчеркиванием (_).

Пример:
.button__icon_size_large {
    /* Стили для большой иконки внутри кнопки */
}

#### Практическое использование:

- Используйте БЭМ для организации стилей.


### Использование Storybook

#### Установка и запуск
Установите зависимости:

```
cd frontend
npm install
```

#### Запустите Storybook:
```
npm run storybook
```
Storybook откроется по адресу http://localhost:6006.

#### Примеры
См. storybook/example-files с документацией и примерами использования, предоставленными storybook при установке.
