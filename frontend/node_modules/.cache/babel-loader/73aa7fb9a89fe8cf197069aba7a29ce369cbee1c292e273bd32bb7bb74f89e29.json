{"ast":null,"code":"import axios from 'axios';\nconst API = axios.create({\n  baseURL: 'http://127.0.0.1:8000/api/v1/',\n  headers: {\n    'Content-Type': 'application/json'\n  }\n});\nlet isRefreshing = false;\nlet failedRequestsQueue = [];\nconst processQueue = (error, token = null) => {\n  failedRequestsQueue.forEach(prom => {\n    if (error) {\n      prom.reject(error);\n    } else {\n      prom.resolve(token);\n    }\n  });\n  failedRequestsQueue = [];\n};\nasync function refreshTokens() {\n  const refreshToken = localStorage.getItem('refreshToken');\n  if (!refreshToken) {\n    throw new Error(\"No refresh token available\");\n  }\n  try {\n    const response = await API.post('token/refresh/', {\n      refresh: refreshToken\n    });\n    const {\n      access: newAccessToken,\n      refresh: newRefreshToken\n    } = response.data;\n    localStorage.setItem('accessToken', newAccessToken);\n    localStorage.setItem('refreshToken', newRefreshToken);\n    API.defaults.headers.common['Authorization'] = `Bearer ${newAccessToken}`;\n    return newAccessToken;\n  } catch (error) {\n    console.log(error.message);\n  }\n}\nAPI.interceptors.request.use(config => {\n  const accessToken = localStorage.getItem('accessToken');\n  if (accessToken) {\n    config.headers['Authorization'] = `Bearer ${accessToken}`;\n  }\n  return config;\n}, error => {\n  return Promise.reject(error);\n});\nAPI.interceptors.response.use(response => response, async error => {\n  const originalRequest = error.config;\n  if (error.response.status === 401 && !originalRequest._retry) {\n    if (isRefreshing) {\n      return new Promise(function (resolve, reject) {\n        failedRequestsQueue.push({\n          resolve,\n          reject\n        });\n      }).then(token => {\n        originalRequest.headers['Authorization'] = 'Bearer ' + token;\n        return API(originalRequest);\n      }).catch(err => {\n        return Promise.reject(err);\n      });\n    }\n    originalRequest._retry = true;\n    isRefreshing = true;\n    try {\n      const newAccessToken = await refreshTokens();\n      processQueue(null, newAccessToken);\n      return API(originalRequest);\n    } catch (refreshError) {\n      processQueue(refreshError, null);\n      return Promise.reject(refreshError);\n    } finally {\n      isRefreshing = false;\n    }\n  }\n  return Promise.reject(error);\n});\nexport default API;","map":{"version":3,"names":["axios","API","create","baseURL","headers","isRefreshing","failedRequestsQueue","processQueue","error","token","forEach","prom","reject","resolve","refreshTokens","refreshToken","localStorage","getItem","Error","response","post","refresh","access","newAccessToken","newRefreshToken","data","setItem","defaults","common","console","log","message","interceptors","request","use","config","accessToken","Promise","originalRequest","status","_retry","push","then","catch","err","refreshError"],"sources":["C:/Users/aksma/Desktop/inTech prototype/intouch/src/service/axios.js"],"sourcesContent":["import axios from 'axios';\r\n\r\nconst API = axios.create({\r\n  baseURL: 'http://127.0.0.1:8000/api/v1/',\r\n  headers: {\r\n    'Content-Type': 'application/json'\r\n  }\r\n});\r\n\r\nlet isRefreshing = false;\r\nlet failedRequestsQueue = [];\r\n\r\nconst processQueue = (error, token = null) => {\r\n  failedRequestsQueue.forEach(prom => {\r\n    if (error) {\r\n      prom.reject(error);\r\n    } else {\r\n      prom.resolve(token);\r\n    }\r\n  });\r\n\r\n  failedRequestsQueue = [];\r\n};\r\n\r\nasync function refreshTokens() {\r\n  const refreshToken = localStorage.getItem('refreshToken');\r\n  if (!refreshToken) {\r\n    throw new Error(\"No refresh token available\");\r\n  }\r\n  try{\r\n    const response = await API.post('token/refresh/', { refresh: refreshToken });\r\n  const { access: newAccessToken, refresh: newRefreshToken } = response.data;\r\n  localStorage.setItem('accessToken', newAccessToken);\r\n  localStorage.setItem('refreshToken', newRefreshToken);\r\n  API.defaults.headers.common['Authorization'] = `Bearer ${newAccessToken}`;\r\n  return newAccessToken;\r\n  }\r\n  catch(error){\r\n    console.log(error.message);\r\n  }\r\n  \r\n}\r\n\r\nAPI.interceptors.request.use(\r\n  config => {\r\n    const accessToken = localStorage.getItem('accessToken');\r\n    if (accessToken) {\r\n      config.headers['Authorization'] = `Bearer ${accessToken}`;\r\n    }\r\n    return config;\r\n  },\r\n  error => {\r\n    return Promise.reject(error);\r\n  }\r\n);\r\n\r\nAPI.interceptors.response.use(\r\n  response => response,\r\n  async error => {\r\n    const originalRequest = error.config;\r\n    if (error.response.status === 401 && !originalRequest._retry) {\r\n      if (isRefreshing) {\r\n        return new Promise(function(resolve, reject) {\r\n          failedRequestsQueue.push({ resolve, reject });\r\n        })\r\n        .then(token => {\r\n          originalRequest.headers['Authorization'] = 'Bearer ' + token;\r\n          return API(originalRequest);\r\n        })\r\n        .catch(err => {\r\n          return Promise.reject(err);\r\n        });\r\n      }\r\n\r\n      originalRequest._retry = true;\r\n      isRefreshing = true;\r\n\r\n      try {\r\n        const newAccessToken = await refreshTokens();\r\n        processQueue(null, newAccessToken);\r\n        return API(originalRequest);\r\n      } catch (refreshError) {\r\n        processQueue(refreshError, null);\r\n        return Promise.reject(refreshError);\r\n      } finally {\r\n        isRefreshing = false;\r\n      }\r\n    }\r\n\r\n    return Promise.reject(error);\r\n  }\r\n);\r\n\r\nexport default API;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}